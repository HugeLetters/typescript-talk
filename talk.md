- Иерархия системы типов

  > Я подготовил доклад по системе типов в Тайпскрипте. Это не доклад про внутренную работу компилятора, оптимизации или малоизвестные фичи. Это доклад про общие концепции, которые, я надеюсь, помогут лучше понимать почему какие-либо ошибки типизации происходят. Я буду рассказывать не про то, как работает тайпскрипт, а как работать с тайпскриптом.
  >
  > Для начала рассмотрим концепцию иерархии типов - я изобразил ее с помощью такого графа. Под иерархией подразумевается то, что типы стоящие выше по иерархии содержат внутри себя типы, которые находятся ниже них по иерархии. Если тип `A` находится выше по иерархии типа `B`, то говорят, что тип `B` входит в тип `A`, или что `B` является подтипом `A`, или также в Тайпскрипте используется термин `extends`, в данном случае получается, что `B extends A`. В верху иерархии находятся два типа - `any` и `unknown`.
  > Они эквивалетны друг другу в том плане, что они оба содержат все остальные типы, потому они называются верхним типом, но также они содержат и друг друга. Как правило это бы означало, что эти два типа равны, но конкретно в этом случае это не совсем так. Об этом чуть далее.
  >
  > `unknown` содержит в себе 3 типа `{}`, `null`, и `void`. Тип `void` включает в себя тип `undefined`. Эти последние три типа обозначают все те значения в джаваскрипте, у которых нет свойств. В общем, все те типы, из-за которых вам приходится писать `?.`.
  >
  > `{}` же наоборот все значения, у которых можно обращаться к свойствам и методам. Как бы парадоксально это ни смотрелось, сюда в том числе входят все примитивы - строки, числа и так далее.
  >
  > Далее этот тип делится на `object`, куда уже как раз входят все не примитивные значения, и остальные типы для примитивов.
  >
  > У всех этих типов также зачастую есть подтипы литералы - типы, описывающие конкретную форму значения. В случае примитивов зачастую эти типы описывают буквально одно конкретное значение, но не всегда. В случае непримитивов они описывают множество значений, зачастую бесконечное, просто с ограничением, какие значения входят в этот тип.
  >
  > А дальше по иерархии нам снова попадается `any` - вот в этом причудливость этого типа, что он одновременно по сути и верхний, и ПОЧТИ что нижний тип. Такое конечно должно быть невозможно, но этот тип был введен именно как такая затычка для случаев, где вы хотите выйти за рамки статической типизации.
  >
  > А вот еще ниже по ирерархии идет настоящий нижний тип - это `never`. То, что это нижний тип означает то, что значений, соответствующих этому типу, не существует. Если у вас где-то в коде появилось значение с типом `never` - как правило означает, что с точки зрения типизации это невозможный сценарий.
  >
  > Это неплохая модель, чтобы для начала понять, что такое верхний тип, что такое нижний тип и что происходит между ними. Но на таком графе сложно понять, где на нем находятся объединения или пересечения типов - где на этом графе `Array<number> | null`? Также на нем плохо видно, как соотносятся между собой всякие непримитивные типы - где относительно друг друга на иерархии находятся `{ a: string }` и `{ a?: string | number }`?
  >
  > **GO TO VENN DIAGRAM**

- Типы как множества

  > Лучше понять как ответить на эти вопросы на поможет диграма Венна - с помощью нее можно изобразить различные множества и как они соотносятся друг с другом. Типы это тоже множества - то есть эдакая коллекция элементов. В данном контексте элементы это всевозможные значения, которые мог бы репрезентовать этот тип.
  >
  > На диаграме видно, что у нас есть тип массив, который является подтипом неизменяемого массива, который является подтипом объекта, который является подтипом `unknown`, который уже является самым верхним типом, вне которого ничего не находится. Это аналогично иерархии, что мы видели ранее на графе. Чем выше тип, тем больше значений в него входят, тем меньше информации о нем мы знаем. В целом задача типизации указать для значения наиболее возможно низкий тип - ведь тем больше у вас будет информации о значении для работы с ним. Инференс, то есть присваивание типов компилятором, как правило работает по такому же принципу.
  >
  > Допустим, у нас есть строка `"abcde"` - если рассматривать ее тип, то она принадлежит в первую очередь очевидно к типу `string`, но также она может быть выражена типом `string | Date` - никакого противоречия тут нет. Можем даже выразить ее типом `unkown`. Но например, если у нас есть какая-то величина типа `string | Date`, то мы не можем ее выразить типом `string` - ведь тогда теряется информация о потенциальном состоянии, в котором может быть значение, то есть `Date`.
  >
  > Типы, стоящие ниже по иерархии можно присваивать к типам, стоящим выше, но не наоборот. Вы можете сказать о любом, кто проживает в Москве, что он проживает в России, но вы не можете сказать, что любой кто проживает в России проживает в Москве. Любая строка в том числе является типом `unknown`, но не все величины типа `unknown` будут являться строкой.

- Unions

  > Но также тут лучше видны отношения между типами - тип `string | Date` включает в себя часть пространства `object` и также часть `string | number`. `|` это `Union`, то есть объединение типов - такое логическое ИЛИ. При операции объединения итоговый тип получается такой же или выше по иерархии, чем был до этого.

- Intersections

  > Если нас интересует пересечение типов `string | Date` и `string | number`, то мы также видим его на диаграме - это будет просто множество всех строк. `&` это `Intersection`, то есть перечение типов - логическое И. Эта операция наоборот нам дает либо такой же тип, либо ниже по иерархии.
  >
  > Касаемо того как это изображено на диаграме - это лишь иллюстрация, так что размеры, расположение кругов особого значения не имеют - нас по большому счету волнует только каким образом эти множества пересекаются: целиком, частично или вообще не пересекаются. Поэтому, например, множество `string | number` у нас представлено двумя раздельными областями - так в принципе возможно.
  >
  > **GO TO SECOND VENN DIAGRAM**
  >
  > Тут же находится наш нижний тип `never` - он находится на пересечении всех типов. Это пустое множество, так как значений данного типа не существует. Нарисовать конечно все наши области так, чтоб они еще и все пересекались в одной точке - проблематично, но опять же напоминаю, что это все очень условное изображение.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Any`**
  >
  > Может возникнуть резонный вопрос - а где же на этой диаграме `any`? Это как раз возвращаясь к тому, о чем я говорил ранее, что это то ли верхний, то ли нижний тип - так как тип построен на противоречии, он в эту модель особо не встраивается.
  >
  > Например, у `any` есть еще вот такое специфическое свойство - сделаем проверку, является ли `unknown` подтипом `never`. Ожидаемо получим `false`. Аналогичная проверка на `never` дает `true` - любой тип является своим же подтипом. А вот `any` на эту проверку дает ни `false`, ни `true`, а сразу оба значения одновременно. При этом присвоить значение типа `any` к типу `never` - уже нельзя. В общем, стоит держать такие моменты в уме.

- Assignability

  > Вот мы разобрались, как работает иерархия типов между собой - примерно стало понятно, что означает, когда один тип является подтипом другого. Но как вообще понять глядя на два типа, где они находятся по иерархии относительно друг друга?
  >
  > Начнем с того, что типизация в Тайпскрипте - структурная. Что это значит? Чаще в статически типизированных языках встречается номинальная типизация - то есть отношения типов в первую очередь регулируются их идентификаторами.
  >
  > **SHOW CODE SNIPPET - `Assignability > Nominal`**
  >
  > В номинальных языках эти бы два типа не были равнозначны - у них разный идентификатор. Но у нас эти два типы равны, потому что у них одинаковая структура. Как быть с более сложными типами? Вот тут вернемся снова к идее о том, что типы это множества.
  >
  > Что такое множество? Это просто какой-то набор элементов - с конечными множествами все понятно вполне: элементы можно просто перечислить. Но вот большинство множеств - они, скорее, определяеются набором требований, которым соотвествуют элементы этого множества. Например, множество всех четных чисел - мы же его определяем не как 2, 4, 6 и так далее, а как все числа, которые нацело делятся на 2.
  >
  > Вот с типами так же - какие-то типы отображают конечное количество элементов, например `"a"|"b"`, но большинство типов имеют бесконечное количество элементов и определяются уже напрямую требованиями к значениям.
  >
  > **SHOW CODE SNIPPET - `Assignability > MinimalContract`**
  >
  > Рассмотрим функцию, которая на вход принимает `MutationObserver` - данный тип выставляет нам довольно небольшой набор требований: у нас должно быть 3 метода, в числе которых метод `takeRecords` должен возвращать массив. Можно также заметить, что метод `observe` должен принимать на вход какие-то аргументы.
  > Определим объект, на котором будут методы с необходимыми названиями, а также добавим метод `log`. Попробуем передать наш объект в функцию - никаких ошибок. Почему так?
  >
  > Во-первых, все необходимые методы на нашем объекте имеются. Метод `takeRecords` возвращает массив, как и требовалось. Во-вторых, что насчет лишнего метода `log`? Ну, функцию его наличие никак не заботит - она о его существовании не знает, от его наличия хуже никому не стало. В-третьих, что с методом `observe` - разве он не должен уметь принимать на вход аргументы? Ну, если мы сравним методы `obverse` между нашим объектом и `MutationObserver`, то увидим, что наш метод является подтипом второго. Почему так? Что случится, если в наш метод передать какой-то параметр? Ну ведь ничего и не случится, так как наш метод аргументы никак не обрабатывает. Получается, по всем требованиям наш объект подходит.
  >
  > Для всего это есть удобное понятие - минимальный контракт. Типы выставляют некий список требований - типы значений проверяются на соответствие этим требованиям. Это и называется минимальным контрактом.
  >
  > **SHOW CODE SNIPPET - `Assignability > Juggler`**
  >
  > Представьте, что вы хотите нанять жонглера и в качестве требования к работе у вас - умение жонглировать. Если к вам придет кандидат, который этого не умеет - вы его отклоните. Если к вам придет кандидат, который умеет жонглировать, а также умеет играть на гитаре - ну, вам лишь важно, чтоб жонглировать умел. При этом нанимать кандидата, про которого неясно то ли он умеет жонглировать, то ли играть на гитаре - вы бы не стали. Это как раз аналогично тому, как при объединении типов теряется информация.
  >
  > **SHOW CODE SNIPPET - `Assignability > Spy`**
  >
  > Представим другую ситуацию. Вам поручили поймать вражеского шпиона на какой-то вечеринке. У вас на руках три разных досье, в которых информация как можно опознать шпиона. В первом досье сказано, что у шпиона голубые глаза. Во втором, что у него голубые глаза и борода. А в третьем, что у него то ли голубые глаза, то ли борода. Какое из трех досье дает вам больше всего информации и с которым найти шпиона будет проще всего? Со вторым, так как под это описание попадает наименьшее число людей. А вот под третье наибольшее. Это как раз аналогично тому, как пересечения сужают типы, а объединения расширяют.

  > **SHOW CODE SNIPPET - `Assignability > WhatIsToBeNarrower`**
  >
  > Рассмотрим на конкретных примерах. Вот глядя на эти два объекта - может по началу показаться, что первый тип является подтипом второго, потому что второй тип выглядит "больше". На самом деле, ровно наоборот - ведь второй тип выставляет дополнительные требования к значениям. При этом следует понимать, что чем больше требований выполняется, тем больше вещей "умеют" делать значения этого типа. Если один тип является подтипом другого - это значит, что он умеет все то же самое, что и другой тип, но также что-то еще дополнительно. Вот первый тип все что умеет - это свойство `a`, а вот у второго типа есть еще и свойство `b`.
  >
  > При этом если мы рассмотрим два следующих объекта, то уже увидим, что они никак не связаны. Это означает, что ни один тип не является подтипом другого.
  >
  > **GO TO THIRD VENN DIAGRAM**
  >
  > Это может быть лучше видно на такой диаграме - внешний круг это множество всех объектов со своством `a` типа `string | number`. А внутри него содержатся два подтипа, которые мы рассматривали - но ни один из них не содержит в себе целиком другой.
  >
  > Продолжая прошлый пример с функцией `observe` - первая функция принимает опциональный аргумент абсолютно любого типа, вторая функция не принимает никаких аргументов. Тем не менее сравнение этих типов сообщаем нам, что они эквивалетны. Первую функцию можно вызывать без параметра, ведь он опционален. Вторую функцию тоже можно. Первую функцию можно вызвать с параметром любого типа. Но ведь как мы уже разобрались ранее, это верно и для второй функции. То есть свойства у этих функций и правда идентичны.
  >
  > **SHOW CODE SNIPPET - `Assignability > Never`**
  >
  > К слову о том, что чем больше свойств - тем ниже тип. А что насчет `never`? Раз это такое пустое множество, то и свойств у него, наверное, никаких нет? Но это вроде бы противоречит тому, что мы опредилили до этого? Чем ниже тип, тем больше свойств. Ну вот, на самом деле, свойств у `never` и правда очень много, а если точнее `never` умеет абсолютно все.
  > Если вспомнить, что `never` как правило получается при пересечении всяких несовместимых типов, то становится чуть яснее почему так. Если при пересечении типов, мы получаем тип, обладающий всеми свойствами их, то `never` обладает абсолютно всеми свойствами.
  > Поэтому можно столкнуться с такой неочевидной вещью, как `keyof never` - это `string | number | symbol`. Надеюсь, теперь стало понятнее почему так. И собственно, поэтому обращаться мы можем к любым его свойствам без каких-либо ошибок.
  >
  > **SHOW CODE SNIPPET - `Assignability > PropertyModifiers`**
  >
  > Модфикаторы свойств тоже могут влиять на иерархию типа.
  >
  > Опциональные свойства находятся выше - поскольку мы ослабляем требование для значений. Тип слева требует наличие свойства, тип справа позволяет и значение, у которых есть это свойство этого типа, и те, у которых его нет.
  >
  > Тем не менее Тайпскрипт не выделяет в этом плане неизменяемые свойства - формально возможность изменять объект это дополнительное требование и мы должны были бы наблюдать что первый тип является подтипом второго.
  >
  > Также просто держите в уме, что Тайпскрипт делает немало допущений касаемо опциональных свойств. Как например, в данном случае - в обоих примерах типы не связаны друг с другом, но Тайпскрипт считает иначе.
  >
  > Также когда в качестве ключа объекта указывается какой-то бесконечный тип, например `string`, то подразумевается, что все эти свойства опциональные - это называется `index signature`. Заметьте, что Тайпскрипт ожидаемо не требует, чтобы я у значениях указал все возможные ключи-строки, так как это, разумеется, невозможно.

- Generics

  > **SHOW CODE SNIPPET - `Generics > Types`**
  >
  > Для того, чтобы подвести к следующей важной теме, я постараюсь вкратце объяснить, что такое дженерик типы. В джаваскрипте мы как правило условно разделяем значения и функции: значения это какие-то величины, с которыми мы работаем, а функции принимают значения на ввод и выдают новые значения. Если мы представим, что обычные типы это значения, то дженерик-типы - это что-то вроде функций. Например, `Array<T>` это пример дженерика и вот как его можно определить самому. `T` это параметр, который мы передаем в дженерик. Дженерик тип это некая операция или трансформация, которую мы применяем к другому типу.

- Variance

  > **SHOW CODE SNIPPET - `Variance > Covariance`**
  >
  > И вот теперь мы подходим к теме, которая звучит страшнее, чем она есть на самом деле, а знать которую очень и очень полезно - речь пойдет про `variance`, "вариативность" по-русски. Не очень понятно, что это вообще значит, да?
  >
  > Вариативность это свойство, которое говорит нам, в какую сторону по нашей иерархии будет двигаться тип при трансформациях. А простым языком - если мы возьмем два типа `A` и его подтип `B`, то если мы прогоним оба этих типа через какой-то дженерик `G`, то `G<B>` будет подтипом `G<A>` или нет?
  >
  > Первым вариантом является ковариативность - она означает, что чем более высокий тип будет передан в дженерик, тем более высокий тип мы получим на выходе. Вот у нас есть два типа `Narrow` и `Wide`, где первый является подтипом второго. Определим дженерик `WithA`, который будет просто создавать объект со свойством `a` и переданным типом. Теперь применим этот дженерик к каждому из наших типов и посмотрим как эти два типа соотносятся друг с другом - видно, что типы сохранили иерархию относительно друг друга.
  >
  > Массивы тоже ковариативны в Тайскрипте...хотя вообще это неправда. Это можно увидеть на таком вот примере - внезапно в нашем массиве из чисел появился `null`, что нехорошо. Это допущение со стороны Тайпскрипта, но держать в уме его стоит. В целом, на самом деле, это распространяется на все значения, которые можно редактировать - вот аналогичный пример с объектом.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > Keyof`**
  >
  > Что же такого не учитывает Тайпскрипт, что выходит такая ошибка? Дело в том, что Тайпскрипт, пусть и намеренно, игнорирует в данном случае второй вид вариативности - контрвариативность. Давайте вспомним, о чем говорили ранее - чем больше свойств объекта, тем ниже тип, и наоборот. А чем больше свойств объекта, тем у него больше чего? Тем у него больше ключей. Чем больше ключей, тем выше должен быть тип, описывающий множество всех ключей. То есть выходит что чем ниже тип, тем выше тип множества его ключей, так?
  >
  > Давайте определим три типа - `Normal`, у которого есть одно свойство. После определим его подтип `Narrow`, у которого добавилось еще одно свойство. А после определим наоборот его надтип `Wide` - может показаться, что этот тип идентичен предыдущему `Narrow`, но это не так. Прошлый `Narrow` тип гарантирует наличие обоих свойств, новый `Wide` - гарантирует лишь наличие какого-то одно из двух. Теперь определим дженерик тип `Keyof`, который будет возвращать нам ключи, определенные на типе. И посмотрим, что он нам будет возвращать для каждого из наших типов - для наиболее нижнего `Narrow` ожидаемо возвращает оба ключа, определенных на типе, для следующего `Normal` один ключ, а вот для самого верхнего типа `Wide` почему-то `never`.
  >
  > Почему так? Ну, тут можно посмотреть с двух сторон. Когда мы запрашиваем ключи у типа - мы получаем список ключей, которые ГАРАНТИРОВАННО существуют на объекте. И в данном случае гарантировать мы не можем вообще ничего. Можно еще попробовать объяснить так - вспоминаем установку, что чем больше свойств, тем ниже тип, а чем их меньше, тем выше тип. Если наш тип `Wide` является надтипом `Normal`, то свойств у него должно быть меньше, то есть и ключей. Раз у `Normal` из ключей лишь один `"a"`, то ниже уже только `never`.
  >
  > Так вот и что же такое контрвариативность? Посмотрим на отношения между нашими типами после `Keyof` трансформации - если `Narrow` был подтипом `Normal`, то `Keyof<Narrow>` является надтипом `Keyof<Normal>`. С остальными типами аналогично. То есть иерархия наоборот перевернулась - чем более высокий тип мы передаем в дженерик, тем более низкий тип мы получаем на выходе. Это и есть контрвариативность.
  >
  > Два самых ярких ее примера - это как раз ключи на объекте: чем ниже тип объекта, тем выше тип его ключей. Другой такой пример - это параметры на функции. Именно параметры, возвращаемый тип функции уже как раз ковариативен.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > Function`**
  >
  > Может быть не очень интуитивно почему оно вообще так. Давайте посмотрим на это с такой стороны: чем больше разного рода параметров ваша функция принимает на ввод, тем сложнее ее написать. Функций, которые принимают на вход только строки меньше, чем функций, которые принимают на вход и строки, и числа. Если посмотреть наш пример, то функция `Func<Narrow>` умеет принимать на вход только строки, а вот функция `Func<Wide>` умеет все то же самое, так вдобавок еще умеет принимать и числа - ну то есть чем больше вещей умеет тип, тем он ниже.
  >
  > Если посмотреть на конкретном примере, то вот две идентичные функции, но вторая умеет обрабатывать еще и числа. При этом если вторую функцию вызывать только со строками - ее поведение будет абсолютно идентично поведению первой функции.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > Function`**
  >
  > Контрвариативность в квадрате, кстати, дает ковариативность - если мы определим такой дженерик, возвращающий функцию, которая принимает на вход другую функцию, которая принимат на вход указанный тип, то контрвариативность, так сказать, отменят друг друга. Первый уровень контрвариативности в том, что у нас функция с параметром, а второй уровень контрвариативности в том, что этот параметр - это не просто указанный тип, а сам по себе функция с параметром указанного типа.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > UnionAndIntersection`**
  >
  > Как следствие контрвариативности можно еще наблюдать занятный эффект с объединениями и пересечениями. Сразу дисклеймер: то, что я покажу работает далеко не всегда, но на простых примерах, где параметр дженерика задействован лишь один раз - например, в нашем дженерике `Func<T>` у функции всего один параметр `T`, а не два, - на таких примерах можно наблюдать эффект, что операция инвертирует объединения в пересечения и наоборот.
  >
  > Сделаем пару типов, на которых будем работать - тип `"a" | "c"` и `"b" | "c"`, у них есть пересечение: это тип `"c"`. Сделаем также два объекта с данными ключами. Так вот, можем наблюдать, что ключи объединения наших двух объектов это то же самое, что пересечение ключей каждого из объектов. Ключи `ACRecord` это `"a" | "c"`, ключи `BCRecord` это `"b" | "c"` - их пересечение это `"c"`. А какие ключи у типа `ACRecord | BCRecord`? Ну, вспоминаем, что как результат мы получаем только ключи, которые гарантированно есть на типе, то есть опять же только `"c"`.
  >
  > То есть если лаконично это все изложить, то ключи объединения всех объектов равны пересечению ключей каждого из объектов. Это свойство работает не на все дженерики, как я уже говорил, но в случае ключей работает всегда, если не ошибаюсь. Есть аналогичный пример с функцией, но нам уже немного проявляется тот факт, что работает это не всегда - тайпскрипт вот считает, что эти два типы не равнозначны. Тем не менее если попытаться вызвать обе этих функции, то видно, что они принимают одинаковые аргументы.
  >
  > Это свойство работает и в обратную сторону - ключи пересечения всех объектов равны объединению ключей каждого из объектов. Мы берем пересчение объектов `ACRecord` и `BCRecord` - то у итогового объекта должны быть свойства из обоих объектов. Получается, у итогового объекта есть все ключи `"a" | "b" | "c"`. Во втором же случае мы объединяем ключи `ACRecord`, то есть `"a" | "c"`, с ключами `BCRecord`, то есть `"b" | "c"` - получается опять же `"a" | "b" | "c"`. Ну и опять же аналогично работает с нашим дженериком `Func<T>`.
  >
  > Когда с этим можно столкнуться на практике? В чате какое-то время назад был вопрос по примерно такому случаю - есть массив из функций, где одна принимает на вход только строки, а другая только числа. И мы хотим пройтись по этому массиву и вызвать каждую функцию - но при попытке это сделать у нас ошибка, что наша функция принимает на вход только `never`. У нас уже есть ответ на вопрос, почему так происходит - раз мы проходим по массиву из функций, то элементом массива является объединение функций в нем. На данном этапе пока не очень видно, что происходит с параметром нашей функции - а вот как только мы попытаемся ее вызвать, уже становится видно: мы получиили объединение `string` и `number` как и ожидали, то есть `never`. Поскольку мы внутри коллбэка не знаем, что именно за функцию мы вызываем, то мы ничего с ней сделать и не можем - если мы передадим строку, а вызовется функция, которая принимает только числа, то у нас будет рантайм ошибка, которых мы хотим избежать.
  >
  > На втором примере видно, что если взять функции, у которых аргументы пересекаются все же - обе функции способны принимать значение `"c"`, то в коллбэке уже нет ошибки, но вызвать функцию со значением `"a"` или `"b"` все так же нельзя.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > Function`**
  >
  > Третий тип вариативности, на самом деле, самый частый - это инвариативность. Это означает, что наша трансформация приводит к тому, что между типами теряется иерархия. Самый просто пример этого функция, которая принимает на вход параметр некоего типа `T` и возвращает этот же параметр в том или ином виде. Рассмотрим самый базовый пример это тождественная функция - то есть функция принимает значение на вход и его же возвращает. Если мы сравним таких две функции, сделанных из низкого типа `Narrow` и высокого типа `Wide`, то увидим, что получившиеся функции никак друг с другом не связаны - ни одна не является подтипом другой. Так получается из-за того, что как мы помним параметры функций контравариативны, а вот возвращаемое значение, как я упоминал ранее - ковариативно. Ну и поскольку у дженерика `Identity` одновременно получается и ковариативная, и контрвариативная трансформация, то итоговый тип инвариативен - это, в общем, самая частая причина инвариативности.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > Object`**
  >
  > Вот другой пример инвариативности, где дженерик `SelfRecord` создает объект с указанными ключами и в качестве значений те же самые ключи. Опять же поскольку ключи контрвариативны, а значения ковариативны - по итогу получается инвариативность.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > Array`**
  >
  > А вот теперь вернемся к массивам - ранее мы наблюдали, что тайпскрипт не предупреждает нас об ошибке по отношениям к массивам, но было не до конца понятно, в чем допущение. Допущение в том, что на самом деле изменяемые массивы - тоже инвариативны. Потому что у нас есть элементы массива по индексам - они ковариативны, а вот всякие методы типа `push` уже контрвариативны. К сожалению, прямо на массивах я этого продемонстрировать не смогу, и позже я объясню даже почему - поэтому для демонстрации сделаем свой минимальный аналог массива, в котором есть элементы по индексу и метод `push`. И опять получается аналогичная ситуация, что элементы массива ковариативны, а вот `push` контрвариативен.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > ReadonlyArray`**
  >
  > Неизменяемые массивы, кстати, ковариативны и с ними проблем нет - тут правда слегка запутанная история выходит почему так. Для начала может показаться, что методы по типу `concat` все портят - ведь они тоже в качестве аргумента принимают тот же тип, что у элементов массива. Ну то есть, в общем, опять контрвариативные и все нам портят. Тут, на самом деле, ситуация такая, что просто тайпскрипт решил не переусложнять и ограничить `concat` таким образом. Но если мы определим свой `concat` метод, который будет делать, в общем, то же самое, но принимать любые аргументы на вход, а возвращать уже новый массив с учетом типов добавленных элементов - то проблема исчезнет. И как мы можем наблюдать наш кастомный неизменямый массив и правда ковариативен. Тем не менее неизменямые массивы ковариативны и на практике по причине существования четвертого вида вариативности...
  >
  > **SHOW CODE SNIPPET - `Variance > Bivariance > Constant`**
  >
  > ...Бивариативность. Это в целом довольно редкий покемон, увидеть которого можно, в основном, в двух случаях - в тривиальном случае, который малоинтересен, и в случае, который стоит избегать всеми силами.
  >
  > Тривиальный случай, это когда дженерик совершенно никак не зависит от указанного параметра - например такой тип `Null<T>`, который просто всегда возвращает `null`. Очевидно, что на практике от такого типа никакого толку нету, но там не менее если мы все же сравним, что будет если применить этот дженерик к нашим `Narrow` и `Wide` типам, то ожидаемо получим, что результаты эквивалетны друг другу.
  >
  > Бивариативность, это когда имея дженерик `F<T>` и при условии что `A` является подтипом `B`, то `F<A>` является подтипом `F<B>` и наоборот тоже, одновременно. Если два типа являются подтипами друг друга одновременно, то как правило это означает что это один и тот же тип - аналогично тому если `a<=b` и `b<=a`, то очевидно, что `a=b`. Но как мы уже видели ранее тайпскрипт делает допущения в некоторых случаях и "взаимная подтипность" не всегда означает равенство типов. Тем не менее в любой непротиворечивой системе типизации бивариативность наблюдается только вот с такими "постоянными" дженериками.
  >
  > **SHOW CODE SNIPPET - `Variance > Bivariance > Method`**
  >
  > Есть еще один случай, в котором Тайпскрипт намеренно допускает бивариативность - это объявления методов. Есть два способа объявить метод на каком-то объекте - это указать его как метод или указать его как свойство функцию. Объявление методом выглядит следующим образом - сделаем дженерик `Method<T>` который будет создавать объект с методом `a`. И вот что необычно - указав в дженерике наши типы `Narrow` и `Wide` итоговые типы `Method<Narrow>` и `Method<Wide>` оказываются эквивалентны друг другу. Хотя исходя из наших прошлых наблюдений про контрвариативность - мы бы ожидали увидеть, что `Method<Wide>` это подтип `Method<Narrow>`.
  >
  > В отличие от постоянных дженериков - не любые два типа произведут эквивалетные типы. Важно, чтобы один из исходных типов был подтипом другого. Если же типы не связаны по иерархии - то и итоговые типы тоже никак связаны не будут.
  >
  > Тайпскрипт это именно допускает намеренно, чтобы не замучивать вас при наследовании классов и так далее - собственно, именно это и есть разгадка к тому, почему массивы считаются ковариативными в Тайпскрипте. Все методы на интерфейсе `Array` объявлены именно как методы, а не свойства.
  >
  > Учтите, что при объявлении методов на самих объектах таким же способов - они тоже будут объявлены как методы. Почти всегда это нежелательное поведение, так что рекомендую этого избегать.
  >
  > **SHOW CODE SNIPPET - `Variance > Bivariance > Property`**
  >
  > Если же мы рассмотрим аналогичные примеры, но где методы объявлены как свойства - то бивариативность теряется, и мы наблюдаем прежнюю контрвариативность.

  <!-- todo - needs an ending -->
