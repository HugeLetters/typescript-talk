- Иерархия системы типов

  > Я подготовил доклад по системе типов в Тайпскрипте. Это не доклад про внутренную работу компилятора, оптимизации или малоизвестные фичи. Это доклад про общие концепции и абстракции, которые, я надеюсь, помогут Вам лучше понимать поведение типов. Я не буду рассказывать про то, как работает тайпскрипт - я постараюсь помочь понять, как работать с тайпскриптом.
  >
  > Для начала рассмотрим концепцию иерархии типов - я изобразил ее с помощью такого графа. Под иерархией подразумевается то, что типы стоящие выше по иерархии содержат в себе типы, которые находятся ниже них по иерархии. Если тип `A` находится выше по иерархии типа `B`, то говорят, что тип `B` входит в тип `A`, или что `B` является подтипом `A`, или также в Тайпскрипте используется термин `extends`, в данном случае `B extends A`. В верху иерархии находятся два типа - `any` и `unknown`.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Graph`**
  >
  > Они эквивалетны друг другу в том плане, что они оба содержат все остальные типы, потому они называются верхним типом, но также они содержат друг друга. В обычных условиях, это бы означало, что эти два типа равны, но это не совсем так. Об этом чуть далее.
  >
  > `unknown` содержит в себе 3 типа `{}`, `null`, и `void`. Тип `void` включает в себя тип `undefined`. Эти последние три типа обозначают все те значения в джаваскрипте, у которых нет свойств. В общем, все те типы, из-за которых вам приходится писать `?.`.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Graph > EmptyObject`**
  >
  > `{}` же наоборот все значения, у которых можно обращаться к свойствам и методам. Как бы парадоксально это ни смотрелось, сюда в том числе входят все примитивы - строки, числа и так далее. Не будем уходить в дебри коробочных значений для примитивов - это доклад про тайпскрипт.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Graph > Object`**
  >
  > Далее этот тип делится на `object`, куда уже как раз входят все не примитивные значения, и остальные типы для примитивов.
  >
  > В типы для примитивов также входят типы для их литералов - то есть конкретных значений. В `string` также входит `template literal` - это похоже на литералы для строк, но позволяет писать темплейт-строки аналогично джаваскрипту. Например, `` `this is a ${string}` ``.
  > В тип `object` входят все не примитивные значения - то есть POJO(то, что как правило мы подразумеваем под объектами), а также `Array`, `Date`, `Set`, `Map`, функции и прочие. И аналогично примитивам, у некоторых этих типов есть что-то вроде аналога литералов - для POJO можно указать, какие конкретно свойства и каких типов нам нужны. У массивов существует подтип `tuple` - это массив фиксированной длины, самый простой пример это `useState` в Реакте, он возвращает тупль `[state, setState]`.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Graph > Function`**
  >
  > У функций в качестве подтипов существуют классы, и `function type expression`, с помощью которых можно изобразить конкретно форму функции, которая нас интересует: что принимает на ввод, что возвращает. То, что я перечислил аналоги литералов - это именно что аналоги. Литералы у примитивов как правило, если не всегда, соотносятся с каким-то одним конкретным значением - вот у объектов не так, поэтому я и сказал, что это аналогично литералам. У объектов подобные типы описывают все равно множество величин, причем вполне вероятно бесконечное - просто с ограничением на то, какие величины подходят под этот тип.
  >
  > А дальше по иерархии нам снова попадается `any` - вот в этом причудливость этого типа, что он одновременно по сути и верхний, и ПОЧТИ нижний тип, что формально не должно быть возможно. Но этот тип был введен именно как такой костыль/затычка для крайних случаев, где корректную типизацию внедрить не удавалось.
  > А вот еще ниже по ирерархии идет настоящий нижний тип - это `never`. То, что это нижний тип означает то, что таких значений существовать не должно - если у вас где-то в коде появилось значение с типом `never` - как правило, но не всегда, означает, что с точки зрения типизации это невозможный сценарий.
  > Это неплохая модель, чтобы для начала понять, что такое верхний тип, что такое нижний тип и что происходит между ними. Но на таком графе сложно понять, где на ним находятся объединения или пересечения типов - где на этом графе `({ a: string } & { b?: number }) | null`? Также на нем плохо видно, как соотносятся между собой всякие непримитивные типы - где относительно друг друга на иерархии находятся `{ a: string }` и `{a?: string | number }`?
  >
  > **GO TO VENN DIAGRAM**

- Типы как множества

  > Лучше понять как ответить на эти вопросы на поможет диграма Венна - с помощью нее можно изобразить различные множества и как они соотнятся друг с другом. Типы это тоже множества - то есть эдакая коллекция элементов: в данном контексте элементы это всевозможные значения, которые мог бы репрезентовать этот тип.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Venn`**
  >
  > Величина `"abcde"` представлена типом `string`, но также она может быть представлена типом `"abcde"` или типом `unknown`.
  > На диаграме видно, что у нас есть тип массив, который является подвидом неизменяемого массива, который является подвидом объекта, который является подвидом `unknown`. Это аналогично иерархии, что мы видели ранее на графе.

- Unions

  > Но также тут лучше видны отношения между типами - тип `string | object` находится рядом с множеством объектов, но также включает в себя дополнительное пространство - множество строк. `|` это Union, то есть объединение типов - такое логическое ИЛИ. При операции объединения итоговый тип получается такой же или выше по иерархии, чем был до этого - то есть количество потенциальных значений, которые попадают под этот тип увеличивается и он уже менее точно описывает поведение значения, которое он репрезентует. Если не совсем понятно, почему так - вспоминаем, что самый верхний тип это `unknown`, то есть про значение этого типа мы не знаем вообще ничего.

- Intersections

  > Если нас интересует пересечение типов `string | object` и `string | number`, то мы также видим его на диаграме - это будет просто множество всех строк. `&` это Intersection, то есть перечение типов - логическое И. Эта операция наоборот нам дает либо такой же тип, либо ниже по иерархии. Чем ниже тип - тем точнее он описывает значение, тем для нас лучше. В целом задача типизации подобрать наиболее низкий тип - если мы будет в качестве типа указывать тип выше, чем нам нужно, у нас будет меньше информации, с которой мы можем работать, но при этом мы не должны указывать тип ниже, чем нам нужно - чтобы не отсеивать значения, которые нам тоже могли бы подойти. Примерно по такому принципу и работает сам инференс в тайпскрипте - когда вы не указываете тип величины прямо, он старается подобрать наиболее низкий тип, который бы не противоречил указанной величине.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Intersection`**
  >
  > Вот, например, у нас есть величина, которая может быть `"one" | "two"`. Мы можем ее присвоить к величине с типом `"string"` - противоречия нет. Можем присвоить к величине типа `"string" | "number"` - да, мы теряем какую-то информацию в данном случае, в будущем придется учитывать, что величина возможно является числом, хотя мы могли бы этого избежать, указав более точный тип. Тем не менее присвоить к величине с типом `"one"` ее нельзя - мы указываем тип ниже действительного, что может легко привести к ошибке, так как мы скрываем информацию о потенциальном состоянии, в котором может быть наше значение.
  >
  > Касаемо того как это изображено на диаграме - это лишь иллюстрация, так что размеры, расположение кругов особого значения не имеют - нас по большому счету волнует только каким образом эти множества пересекаются: целиком, частично или вообще не пересекаются. Поэтому, например, множество `string | number` у нас представлено двумя раздельными областями - так в принципе возможно.
  > Из диаграмы также легко видно, где наш верхний тип `unknown` это область, внутри которой находятся абсолютно все другие множества. За пределами этой области ничего нет.
  >
  > **GO TO SECOND VENN DIAGRAM**
  >
  > Тут же находится наш нижний тип `never` - он находится на пересечении всех типов. Это по сути пустое множество, ни одна джаваскриптовая величина не может быть представлена этим типов. Нарисовать конечно все наши области так, чтоб они еще и все пересекались в одной точки - проблематично, но опять же напоминаю, что это все очень условное изображение.
  >
  > **GO TO THIRD VENN DIGRAM**
  >
  > Можно попробовать изобразить это вот так - где красная область это `never`. То, что это пустое множество не мешает нам нарисовать его не как точку, а как область. В любом случае, на практике об этом приходится думать в контексте 2-3 типов, для которых представить такую диаграму в голове - не проблема, зато понять соотношение типов с такой моделью довольно просто.
  > Может возникнуть резонный вопрос - а где же на этой диаграме `any`? Это как раз возвращаясь к тому, о чем я говорил ранее, что это то ли верхний, то ли нижний тип - так как тип построен на противоречии, он в эту модель особо не встраивается. Это больше к слову о том, о чем я говорил ранее, что это такой костыль - он не бесполезный, но лучше его приберечь для всяких ограничений на дженериках.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Any`**
  >
  > Например, у `any` есть еще вот такое специфическое свойство - сделаем проверку, является ли `unknown` подтипом `never`. Ожидаемо получим `false`. Аналогичная проверка на `never` дает `true` - любой тип является своим же подтипом. А вот `any` на эту проверку дает ни `false`, ни `true`, а сразу оба значения одновременно. В общем, такие вещи стоит держать в уме и не прибегать к `any`, пока реально необходимости не возникло.

- Assignability

  > Вот мы поговорили о том, как иерархии типов между собой - но что, собственно, это вообще значит? Ну вот какой-то тип выше другого по иерархии, то есть в этот тип входит больше элементов, чем в другой - а как это понять глядя на два типа?
  >
  > Начнем с того, что типизация в Тайпскрипте - структурная. Что это значит? Чаще в статически типизированных языках встречается номинальная типизация - то есть отношения типов в первую очередь регулируются их идентификаторами, ну и также наследование там играет свою роль.
  >
  > **SHOW CODE SNIPPET - `Assignability > Nominal`**
  >
  > В номинальных языках эти бы два типа не были равнозначны - у них разный идентификатор. Но у нас эти два типы равны - почему? Потому что у них одинаковая структура - и то, и то это просто строка.
  > Как быть с более сложными типами? Вот тут вернемся снова к идее о том, что типы это множества.
  >
  > Что такое множество? Это просто какой-то набор элементов - с конечными множествами все понятно вполне: элементы можно просто перечислить. Но вот большинство множеств - они, скорее, определяеются набором свойств или требований, которые наблюдаются у элементов этого множества. Например, множество всех четных чисел - мы же его определяем не как 2, 4, 6 и так далее, а как все числа, которые нацело делятся на 2.
  >
  > Вот с типами так же - какие-то типы отображают конечное количество элементов, например `"a"|"b"`, но большинство типов имеют бесконечное количество элементов и определяются уже напрямую свойствами. То есть чтобы понять является ли что-то датой с точки зрения тайпскрипта - мы смотрим на то, какие вообще свойства есть у `Date`, смотрим выполняется ли это все для нашей величины, и если да, то для тайпскрипта наша величина это `Date`.
  >
  > Для всего это есть удобное понятие - минимальный контракт. Типы в тайпскрипте описывают минимальный контракт. Представьте, что вы хотите нанять жонглера и в качестве требования к работе у вас - умение жонглировать. Если к вам придет кандидат, который этого не умеет - вы его отклоните. Если к вам придет кандидат, который умеет жонглировать, а также умеет играть на гитаре - ну, вам лишь важно, чтоб жонглировать умел. То есть вам важно, чтоб выполнялся список ваших минимальных требований, а наличие чего-либо сверху - вас не волнует. При этом если вспоминать про объединение типов и почему это дает нам меньше информации о значении, чем конкретный тип - представьте, если бы кандидат сказал, что, возможно, он умеет либо жонглировать, либо играть на гитаре, но что-то одно. Появляется риск того, что окажется, что кандидат умеет лишь играть на гитаре, хоть и шанс того, что он все же умеет жонглировать никуда не пропал - но это лишь шанс, а не гарантия.
  >
  > **SHOW CODE SNIPPET - `Assignability > MinimalContract`**
  >
  > Вот у нас есть функция, которая на выход принимает `MutationObserver` - данный тип выставляет нам довольно небольшой набор требований: у нас должно быть 3 метода, и метод `takeRecord` должен возвращать массив. Можно также заметить, что метод `observe` должен принимать на вход какие-то аргументы. Выполняет ли наш объект данный контракт? Ну вот казалось бы на первый взгляд почти что да, но на самом деле, да, мы целиком выполняем данный контракт.
  >
  > Во-первых, то, что у нашего объекта есть какой-то лишний метод - функцию соверешенно не волнует, ну есть и есть, она им не пользуется. То есть опять же идея МИНИМАЛЬНОГО контракта - если наш объект умеет что-то еще, ну здорово, но хуже от этого не станет. Во-вторых, что с методом `observe` - разве он не должен уметь принимать на вход аргументы? Наш же метод так не умеет - ну, на самом деле, наш метод является подтипом того метода, который есть на `MutationObserver`. Проще всего это объяснить так - что случится, если в функцию, которая не принимает никаких аргументов, все же их передать? Ну, ничего и не случится - функция эти аргументы никак не обработает, и все. Поэтому с тем, как определен наш метод никаких проблем совершенно нет. Получается, что наш объект выполняет минимальный контракт, обозначенный типом `MutationObserver` - следовательно, функция такое значение принимает.
  >
  > Если мы сравним методы `obverse` между нашим объектом и `MutationObserver`, то увидим, что наш метод считается ниже по иерархии. Может быть не совсем понятно почему так - почему то, что наш метод не принимает никаких аргументов на вход, ставит его ниже.
  >
  > **SHOW CODE SNIPPET - `Assignability > WhatIsToBeNarrower`**
  >
  > Что вообще на простых словах означает для типа быть ниже по иерархии, чем какой-то другой? Вот глядя на эти два объекта - может интуитивно показаться, что первый тип находится ниже по иерархии, ведь он выглядит "меньше". На самом деле, ровно наоборот - чем больше вещей умеет делать тип, тем он в целом ниже по иерархии. Если один тип находится ниже другого - это значит, что он умеет все то же самое, что другой тип, но также что-то еще дополнительно. Вот первый тип все что умеет - это свойство `a`, а вот у второго типа есть еще и свойство `b`. То есть у нас больше возможностей с этим типом.
  >
  > Для объектов в целом действует такое правило на глаз, что чем больше свойств - тип объект ниже. Про типы на самих этих свойствах тоже забывать не стоит - например, в следующем примере нельзя уже сказать, что какой-то тип является подтипом другого.
  >
  > **GO TO FOURTH VENN DIAGRAM**
  >
  > У этих типов может быть какое-то пересечение, может и не быть - но ни один тип не содержит целиком другой.
  >
  > Возвращаясь к нашему примеру с методом - если сравнить две аналогичных функции, но одна из которых принимает на ввод строку, то функция без аргумента будет подтипом второй. Потому что наша вторая функция умеет принимать на ввод только строку, а вот первая функция по сути на ввод принимает абсолютно любое значение.
  >
  > Это чуть лучше видно на втором примере - первую функцию можно вызывать без аргумента, а можно вызвать с любым значением. Ну, все то же самое верно и для второй функции ведь? Понятно, что первая функция подразумевает, что мы что-то с этим аргументом делаем, скорее всего - но именно с точки зрения того, как эту функции можно вызывать - они идентичны.
  >
  > **SHOW CODE SNIPPET - `Assignability > Never`**
  >
  > К слову о том, что чем больше свойств - тем ниже тип. А что насчет `never`? Это же самный нижний тип - ну и раз это такое пустое множество, то и свойств у него, наверное, никаких нет? Но это вроде бы противоречит тому, что мы опредилили до этого? Ну вот, на самом деле, свойств у `never` и правда очень много, точнее их бесконечно много, точнее `never` умеет абсолютно все. Если вспомнить, что `never` как правило получается при пересечении всяких несовместимых типов, то становится чуть яснее почему так. Ну то есть если мы объединяем строку и число, то мы получаем `never` - именно потому, что `never` и является одновременно и строкой, и числой, и вообще всем угодно. Да, такого значения в рантайме у нас быть не может, это действительно пустое множество, но именно как тип он описывает величину, которая умеет абсолютно все на свете. `never` это пустое множество, но сам тип вообще не пустой.
  > Поэтому можно столкнуться с такой неочевидной вещью, как `keyof never` - это любой возможный ключ. И собственно, поэтому обращаться мы можем к любым его свойствам без каких-либо ошибок.
  >
  > **SHOW CODE SNIPPET - `Assignability > PropertyModifiers`**
  >
  > Модфикаторы свойств тоже могут влиять на иерархию типа.
  >
  > Опциональные свойства находятся выше - поскольку мы ослабляем требование для значений. Тип слева требует наличие свойства, тип справа позволяет и значение, у которых есть это свойство этого типа, и те, у которых его нет.
  >
  > Неизменяемые свойства - тут посложнее. Тайпскрипт делает допущение и не считает, что подобный модификатор как-то влияет на тип - тем не менее формально неизменяемые свойства находятся выше по иерархии, так как возможность изменять свойство - это дополнительное требование.
  >
  > С необязательными свойствами в целом довольно много странностей можно наблюдать на следующих примерах - честно, тут какого-то интуитивного правила как это работает у меня сформулировать не получилось, так что это больше к тому, чтоб вы просто держали это в уме на будущее.
  >
  > Стоит также отметить специфику объектом с индекс-свойством - по сути это когда в качестве ключа на объекте указан какой-то "бесконечный тип". Например, если мы укажем тип `Record<"a" | "b", null>`, то оба свойства будут обязательны на объекте - если какое-то не указать, то будет ошибка. А вот если указать тип `Record<string, null>`, то у нас же не вылезает ошибка, что мы должны указать абсолютно все возможные строки в качестве ключа - понятно, что это сделать невозможно, но стоит понимать это разделение, что индекс-свойства - они необязательные по умолчанию. И следовательно, от них тоже можно наблюдахть всякие странности в плане иерархии.

- Generics

  > **SHOW CODE SNIPPET - `Generics > Types`**
  >
  > Для того, чтобы подвести к следующей важной теме, я постараюсь вкратце объяснить, что такое дженерик типы. В джаваскрипте мы как правило условно разделяем значения и функции: значения это какие-то величины, с которыми мы работаем, а функции принимают значения на ввод и выдают новые значения. Если мы представим, что обычные типы это значения, то дженерик-типы - это что-то вроде функций. Например, `Array<T>` это пример дженерика и вот как его можно определить самому. `T` это параметр, который мы передаем в дженерик. Дженерик тип это некая операция или трансформация, которую мы применяем к другому типу.

- Variance

  > **SHOW CODE SNIPPET - `Variance > Covariance`**
  >
  > И вот теперь мы подходим к теме, которая звучит страшнее, чем она есть на самом деле, а знать которую очень и очень полезно - речь пойдет про `variance`, "вариативность" по-русским. Не очень понятно, что это вообще значит, да?
  >
  > Вариативность это свойство, которое говорит нам, в какую сторону по нашей иерархии будет двигаться тип при трансформациях. А простым языком - если мы возьмем два типа `A` и его подтип `B`, то если мы прогоним оба этих типа через какой-то дженерик `G`, то `G<B>` будет подтипом `G<A>` или нет?
  >
  > Первым вариантом является ковариативность - она означает, что чем более высокий тип будет передан в дженерик, тем более высокий тип мы получим нм выходе. Вот у нас есть два типа `Narrow` и `Wide`, где первый является подтипом второго. Определим дженерик `WithA`, который будет просто создавать объект со свойством `a` и переданным типом. Теперь применим этот дженерик к каждому из наших типов и посмотрим как эти два типа соотносятся друг с другом - видно, что типы сохранили иерархию относительно друг друга.
  >
  > Массивы тоже ковариативны в Тайскрипте...хотя вообще это неправда. Это можно увидеть на таком вот примере - внезапно в нашем массиве из чисел появился `null`, что нехорошо. Это допущение со стороны Тайпскрипта, но держать в уме его стоит. В целом, на самом деле, это распространяется на все значения, которые можно редактировать - вот аналогичный пример с объектом.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > Keyof`**
  >
  > Что же такого не учитывает Тайпскрипт, что выходит такая ошибка? Дело в том, что Тайпскрипт, пусть и намеренно, игнорирует в данном случае второй вид вариативности - контрвариативность. Давайте вспомним, о чем говорили ранее - чем больше свойств объекта, тем ниже тип, и наоборот. А чем больше свойств объекта, тем у него больше чего? Тем у него больше ключей. Чем больше ключей, тем выше должен быть тип, описывающий множество всех ключей. То есть выходит что чем ниже тип, тем выше тип множества его ключей, так?
  >
  > Давайте определим три типа - `Normal`, у которого есть одно свойство. После определим его подтип `Narrow`, у которого добавилось еще одно свойство. А после определим наоборот его надтип `Wide` - может показаться, что этот тип идентичен предыдущему `Narrow`, но это не так. Прошлый `Narrow` тип гарантирует наличие обоих свойств, новый `Wide` - гарантирует лишь наличие какого-то одно из двух. Теперь определим дженерик тип `Keyof`, который будет возвращать нам ключи, определенные на типе. И посмотрим, что он нам будет возвращать для каждого из наших типов - для наиболее нижнего `Narrow` ожидаемо возвращает оба ключа, определенных на типе, для следующего `Normal` один ключ, а вот для самого верхнего типа `Wide` почему-то `never`.
  >
  > Почему так? Ну, тут можно посмотреть с двух сторон. Когда мы запрашиваем ключи у типа - мы получаем список ключей, которые ГАРАНТИРОВАННО существуют на объекте. И в данном случае гарантировать мы не можем вообще ничего. Можно еще попробовать объяснить так - вспоминаем установку, что чем больше свойств, тем ниже тип, а чем их меньше, тем выше тип. Если наш тип `Wide` является надтипом `Normal`, то свойств у него должно быть меньше, то есть и ключей. Раз у `Normal` из ключей лишь один `"a"`, то ниже уже только `never`.
  >
  > Так вот и что же такое контрвариативность? Посмотрим на отношения между нашими типами после `Keyof` трансформации - если `Narrow` был подтипом `Normal`, то `Keyof<Narrow>` является надтипом `Keyof<Normal>`. С остальными типами аналогично. То есть иерархия наоборот перевернулась - чем более высокий тип мы передаем в дженерик, тем более низкий тип мы получаем на выходе. Это и есть контрвариативность.
  >
  > Два самых ярких ее примера - это как раз ключи на объекте: чем ниже тип объекта, тем выше тип его ключей. Другой такой пример - это параметры на функции. Именно параметры, возвращаемый тип функции уже как раз ковариативен.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > Function`**
  >
  > Может быть не очень интуитивно почему оно вообще так. Давайте посмотрим на это с такой стороны: чем больше разного рода параметров ваша функция принимает на ввод, тем сложнее ее написать. Функций, которые принимают на вход только строки меньше, чем функций, которые принимают на вход и строки, и числа. Если посмотреть наш пример, то функция `Func<Narrow>` умеет принимать на вход только строки, а вот функция `Func<Wide>` умеет все то же самое, так вдобавок еще умеет принимать и числа - ну то есть чем больше вещей умеет тип, тем он ниже.
  >
  > Если посмотреть на конкретном примере, то вот две идентичные функции, но вторая умеет обрабатывать еще и числа. При этом если вторую функцию вызывать только со строками - ее поведение будет абсолютно идентично поведению первой функции.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > Function`**
  >
  > Контрвариативность в квадрате, кстати, дает ковариативность - если мы определим такой дженерик, возвращающий функцию, которая принимает на вход другую функцию, которая принимат на вход указанный тип, то контрвариативность, так сказать, отменят друг друга. Первый уровень контрвариативности в том, что у нас функция с параметром, а второй уровень контрвариативности в том, что этот параметр - это не просто указанный тип, а сам по себе функция с параметром указанного типа.
  >
  > **SHOW CODE SNIPPET - `Variance > Contravariance > UnionAndIntersection`**
  >
  > Как следствие контрвариативности можно еще наблюдать занятный эффект с объединениями и пересечениями. Сразу дисклеймер: то, что я покажу работает далеко не всегда, но на простых примерах, где параметр дженерика задействован лишь один раз - например, в нашем дженерике `Func<T>` у функции всего один параметр `T`, а не два, - на таких примерах можно наблюдать эффект, что операция инвертирует объединения в пересечения и наоборот.
  >
  > Сделаем пару типов, на которых будем работать - тип `"a" | "c"` и `"b" | "c"`, у них есть пересечение: это тип `"c"`. Сделаем также два объекта с данными ключами. Так вот, можем наблюдать, что ключи объединения наших двух объектов это то же самое, что пересечение ключей каждого из объектов. Ключи `ACRecord` это `"a" | "c"`, ключи `ABRecord` это `"b" | "c"` - их пересечение это `"c"`. А какие ключи у типа `ACRecord | BCRecord`? Ну, вспоминаем, что как результат мы получаем только ключи, которые гарантированно есть на типы, то есть опять же только `"c"`.
  >
  > То есть если лаконично это все изложить, то ключи объединения всех объектов равны пересечению ключей каждого из объектов. Это свойство работает не на все дженерики, как я уже говорил, но в случае ключей работает всегда, если не ошибаюсь. Есть аналогичный пример с функцией, но нам уже немного проявляется тот факт, что работает это не всегда - тайпскрипт вот считает, что эти два типы не равнозначны. Тем не менее если попытаться вызвать обе этих функции, то видно, что они принимают одинаковые аргументы.
  >
  > Это свойство работает и в обратную сторону - ключи пересечения всех объектов равны объединению ключей каждого из объектов. Мы берем пересчение объектов `ACRecord` и `BCRecord` - то у итогового объекта должны быть свойства из обоих объектов. Получается, у итогового объекта есть все ключи `"a" | "b" | "c"`. Во втором же случае мы объединяем ключи `ACRecord`, то есть `"a" | "c"`, с ключами `BCRecord`, то есть `"b" | "c"` - получается опять же `"a" | "b" | "c"`. Ну и опять же аналогично работает с нашим дженериком `Func<T>`.
  >
  > Когда с этим можно столкнуться на практике? В чате какое-то время назад был вопрос по примерно такому случаю - есть массив из функций, где одна принимает на вход только строки, а другая только числа. И мы хотим пройтись по этому массиву и вызвать каждую функцию - но при попытке это сделать у нас ошибка, что наша функция принимает на вход только `never`. У нас уже есть ответ на вопрос, почему так происходит - раз мы проходим по массиву из функций, то элементом массива является объединение функций в нем. На данном этапе пока не очень видно, что происходит с параметром нашей функции - а вот как только мы попытаемся ее вызвать, уже становится видно: мы получиили объединение `string` и `number` как и ожидали, то есть `never`. Поскольку мы внутри коллбэка не знаем, что именно за функцию мы вызываем, то мы ничего с ней сделать и не можем - если мы передадим строку, а вызовется функция, которая принимает только числа, то у нас будет рантайм ошибка, которых мы хотим избежать.
  >
  > На втором примере видно, что если взять функции, у которых аргументы пересекаются все же - обе функции способны принимать значение `"c"`, то в коллбэке уже нет ошибки, но вызвать функцию со значением `"a"` или `"b"` все так же нельзя.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > Function`**
  >
  > Третий тип вариативности, на самом деле, самый частый - это инвариативность. Это означает, что наша трансформация приводит к тому, что между типами теряется иерархия. Самый просто пример этого функция, которая принимает на вход параметр некоего типа `T` и возвращает этот же параметр в том или ином виде. Рассмотрим самый базовый пример это тождественная функция - то есть функция принимает значение на вход и его же возвращает. Если мы сравним таких две функции, сделанных из низкого типа `Narrow` и высокого типа `Wide`, то увидим, что получившиеся функции никак друг с другом не связаны - ни одна не является подтипом другой. Так получается из-за того, что как мы помним параметры функций контравариативны, а вот возвращаемое значение, как я упоминал ранее - ковариативно. Ну и поскольку у дженерика `Identity` одновременно получается и ковариативная, и контрвариативная трансформация, то итоговый тип инвариативен - это, в общем, самая частая причина инвариативности.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > Object`**
  >
  > Вот другой пример инвариативности, где дженерик `SelfRecord` создает объект с указанными ключами и в качестве значений те же самые ключи. Опять же поскольку ключи контрвариативны, а значения ковариативны - по итогу получается инвариативность.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > Array`**
  >
  > А вот теперь вернемся к массивам - ранее мы наблюдали, что тайпскрипт не предупреждает нас об ошибке по отношениям к массивам, но было не до конца понятно, в чем допущение. Допущение в том, что на самом деле изменяемые массивы - тоже инвариативны. Потому что у нас есть элементы массива по индексам - они ковариативны, а вот всякие методы типа `push` уже контрвариативны. К сожалению, прямо на массивах я этого продемонстрировать не смогу, и позже я объясню даже почему - поэтому для демонстрации сделаем свой минимальный аналог массива, в котором есть элементы по индексу и метод `push`. И опять получается аналогичная ситуация, что элементы массива ковариативны, а вот `push` контрвариативен.
  >
  > **SHOW CODE SNIPPET - `Variance > Invariance > ReadonlyArray`**
  >
  > Неизменяемые массивы, кстати, ковариативны и с ними проблем нет - тут правда слегка запутанная история выходит почему так. Для начала может показать, что методы по типу `concat` все портят - ведь они тоже в качестве аргумента принимают тот же тип, что у элементов массива. Ну то есть, в общем, опять контрвариативные и все нам портят. Тут, на самом деле, ситуация такая, что просто тайпскрипт решил не переусложнять и ограничить `concat` таким образом. Но если мы определим свой `concat` метод, который будет делать, в общем, то же самое, но принимать любые аргументы на вход, а возвращать уже новый массив с учетом типов добавленных элементов - то проблема исчезнет. И как мы можем наблюдать наш кастомный неизменямый массив и правда ковариативен. Тем не менее неизменямые массивы ковариативны и на практике по причине существования четвертого вида вариативности...
  >
  > **SHOW CODE SNIPPET - `Variance > Bivariance > Constant`**
  >
  > ...Бивариативность. Это в целом довольно редкий покемон, увидеть которого можно, в основном, в двух случаях - в тривиальном случае, который малоинтересен, и в случае, который стоит избегать всеми силами.
  >
  > Тривиальный случай, это когда дженерик совершенно никак не зависит от указанного параметра - например такой тип `Null<T>`, который просто всегда возвращает `null`. Очевидно, что на практике от такого типа никакого толку нету, но там не менее если мы все же сравним, что будет если применить этот дженерик к нашим `Narrow` и `Wide` типам, то ожидаемо получим, что результаты эквивалетны друг другу.
  >
  > Бивариативность, это когда имея дженерик `F<T>` и при условии что `A` является подтипом `B`, то `F<A>` является подтипом `F<B>` и наоборот тоже, одновременно. Если два типа являются подтипами друг друга одновременно, то как правило это означает что это один и тот же тип - аналогично тому если `a<=b` и `b<=a`, то очевидно, что `a=b`. Но как мы уже видели ранее тайпскрипт делает допущения в некоторых случаях и "взаимная подтипность" не всегда означает равенство типов. Тем не менее в любой непротиворечивой системе типизации бивариативность наблюдается только вот с такими "постоянными" дженериками.
  >
  > **SHOW CODE SNIPPET - `Variance > Bivariance > Method`**
  >
  > Есть еще один случай, в котором Тайпскрипт намеренно допускает бивариативность - это объявления методов. Есть два способа объявить метод на каком-то объекте - это указать его как метод или указать его как свойство-функцию. Объявление методом выглядит следующим образом - сделаем дженерик `Method<T>` который будет создавать объект с методом `a`. И вот что необычно - указав в дженерике наши типы `Narrow` и `Wide` итоговые типы `Method<Narrow>` и `Method<Wide>` оказываются эквивалентны друг другу. Хотя исходя из наших прошлых наблюдений про контрвариативность - мы бы ожидали увидеть, что `Method<Wide>` это подтип `Method<Narrow>`.
  >
  > В отличие от постоянных дженериков - не любые два типа произведут эквивалетные типы. Важно, чтобы один из исходных типов был подтипом другого. Если же типы не связаны по иерархии - то и итоговые типы тоже никак связаны не будут.
  >
  > Тайпскрипт это именно допускает намеренно, чтобы не замучивать вас при наследовании классов и так далее - собственно, именно это и есть разгадка к тому, почему массивы считаются ковариативными в Тайпскрипте. Все методы на интерфейсе `Array` объявлены именно как методы, а не свойства.
  >
  > Учтите, что при объявлении методов на самих объектах таким же способов - они тоже будут объявлены как методы. Почти всегда это нежелательное поведение, так что рекомендую этого избегать.
  >
  > **SHOW CODE SNIPPET - `Variance > Bivariance > Property`**
  >
  > Если же мы рассмотрим аналогичные примеры, но где методы объявлены как свойства - то бивариативность теряется, и мы наблюдаем прежнюю контрвариативность.

  <!-- todo - needs an ending -->
