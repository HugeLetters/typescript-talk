# Иерархия системы типов

Я подготовил доклад по системе типов в Тайпскрипте. Это не доклад про внутренную работу компилятора, оптимизации или малоизвестные фичи. Это доклад про общие концепции, которые, я надеюсь, помогут лучше понимать почему какие-либо ошибки типизации происходят. Я буду рассказывать не про то, как работает тайпскрипт, а как работать с тайпскриптом.

Для начала рассмотрим концепцию иерархии типов - я изобразил ее с помощью такого графа. Под иерархией подразумевается то, что типы стоящие выше по иерархии содержат внутри себя типы, которые находятся ниже них по иерархии. Если тип `A` находится выше по иерархии типа `B`, то говорят, что тип `B` входит в тип `A`, или что `B` является подтипом `A`, или также в Тайпскрипте используется термин `extends`, в данном случае получается, что `B extends A`.

В верху иерархии находятся два типа - `any` и `unknown`.
Они эквивалетны друг другу в том плане, что они оба содержат все остальные типы, потому они называются верхним типом, но также они содержат и друг друга. Как правило это бы означало, что эти два типа равны, но конкретно в этом случае это не совсем так. Об этом чуть далее.

`unknown` содержит в себе 3 типа `{}`, `null`, и `void`. Тип `void` включает в себя тип `undefined`. Эти последние три типа обозначают все те значения в джаваскрипте, у которых нет свойств. В общем, все те типы, из-за которых вам приходится писать `?.`.

`{}` же наоборот включает в себя все значения, у которых можно обращаться к свойствам и методам. Как бы парадоксально это ни смотрелось, сюда в том числе входят все примитивы - строки, числа и так далее.

`{}` делится на все типы для примитивов и `object`, куда уже как раз входят все не примитивные значения.

У всех этих типов также зачастую есть подтипы литералы - типы, описывающие конкретную форму значения. В случае примитивов зачастую эти типы описывают буквально одно конкретное значение, но не всегда. В случае непримитивов они описывают множество значений, зачастую бесконечное, просто с ограничением, какие значения входят в этот тип.

А дальше по иерархии нам снова попадается `any` - вот в этом причудливость этого типа, что он одновременно по сути и верхний, и ПОЧТИ что нижний тип. Такое конечно должно быть невозможно, но этот тип был введен именно как такая затычка для случаев, где вы хотите выйти за рамки статической типизации.

А вот еще ниже по иерархии идет настоящий нижний тип - это `never`. То, что это нижний тип означает то, что значений, соответствующих этому типу, не существует. Если у вас где-то в коде появилось значение с типом `never` - как правило означает, что с точки зрения типизации это невозможный сценарий.

Это неплохая модель, чтобы для начала понять, что такое верхний тип, что такое нижний тип и что происходит между ними. Но на таком графе сложно понять, где на нем находятся объединения или пересечения типов - где на этом графе `Array<number> | null`? Также на нем плохо видно, как соотносятся между собой всякие непримитивные типы - где относительно друг друга на иерархии находятся `{ a: string }` и `{ a?: string | number }`?

# Типы как множества

## Go to `1st Venn diagram`

Лучше понять как ответить на эти вопросы нам поможет диграма Венна - с помощью нее можно изобразить различные множества и как они соотносятся друг с другом. Типы это тоже множества - то есть эдакая коллекция элементов. В данном контексте элементы это всевозможные значения, которые мог бы репрезентовать этот тип.

На диаграме видно, что у нас есть тип массив, который является подтипом неизменяемого массива, который является подтипом объекта, который является подтипом `unknown`, который уже является самым верхним типом, вне которого ничего не находится. Это аналогично иерархии, что мы видели ранее на графе. Чем выше тип, тем больше значений в него входят, тем меньше информации о значении этого типа мы знаем. В целом задача типизации указать для значения наиболее возможно низкий тип - ведь тем больше у вас будет информации о значении для работы с ним. Инференс, то есть присваивание типов компилятором, как правило работает по такому же принципу.

Допустим, у нас есть строка `"abcde"` - если рассматривать ее тип, то она принадлежит в первую очередь очевидно к типу `string`, но также она может быть выражена типом `string | Date` - никакого противоречия тут нет. Можем даже выразить ее типом `unknown`. Но например, если у нас есть какая-то величина типа `string | Date`, то мы не можем ее выразить типом `string` - ведь тогда теряется информация о потенциальном состоянии, в котором может быть значение, то есть `Date`.

Типы, стоящие ниже по иерархии можно присваивать к типам, стоящим выше, но не наоборот. Вы можете сказать о любом, кто проживает в Москве, что он проживает в России, но вы не можете сказать, что любой кто проживает в России проживает в Москве. Любая строка в том числе является типом `unknown`, но не все величины типа `unknown` будут являться строкой.

## Union

Но также на диаграме лучше видны отношения между типами - тип `string | Date` включает в себя часть пространства `object` и также часть `string | number`. `|` это `Union`, то есть объединение типов - такое логическое ИЛИ. При операции объединения итоговый тип получается такой же или выше по иерархии, чем был до этого.

## Intersection

Если нас интересует пересечение типов `string | Date` и `string | number`, то мы также видим его на диаграме - это будет просто множество всех строк. `&` это `Intersection`, то есть перечение типов - логическое И. Эта операция наоборот нам дает либо такой же тип, либо ниже по иерархии.

Касаемо того как это изображено на диаграме - это лишь иллюстрация, так что размеры, расположение кругов особого значения не имеют - нас по большому счету волнует только каким образом эти множества пересекаются: целиком, частично или вообще не пересекаются. Поэтому, например, множество `string | number` у нас представлено двумя раздельными областями - так в принципе возможно.

## Go to `2nd Venn Diagram`

Тут же находится наш нижний тип `never` - он находится на пересечении всех типов. Это пустое множество, так как значений данного типа не существует. Нарисовать конечно все наши области так, чтоб они еще и все пересекались в одной точке - проблематично, но опять же напоминаю, что это все очень условное изображение.

Может возникнуть резонный вопрос - а где же на этой диаграме `any`? Это как раз возвращаясь к тому, о чем я говорил ранее, что это то ли верхний, то ли нижний тип - так как тип построен на противоречии, он в эту модель особо не встраивается.

## Show code snippet - `Hierarchy > Any`

Например, у `any` есть еще вот такое специфическое свойство - сделаем проверку, является ли `unknown` подтипом `never`. Ожидаемо получим `false`. Аналогичная проверка на `never` дает `true` - любой тип является своим же подтипом. А вот `any` на эту проверку дает ни `false`, ни `true`, а сразу оба значения одновременно. При этом присвоить значение типа `any` к типу `never` - уже нельзя. В общем, стоит держать такие моменты в уме.

# Assignability

Вот мы разобрались, как работает иерархия типов между собой - примерно стало понятно, что означает, когда один тип является подтипом другого. Но как вообще понять глядя на два типа, где они находятся по иерархии относительно друг друга?

Начнем с того, что типизация в Тайпскрипте - структурная. Что это значит? Чаще в статически типизированных языках встречается номинальная типизация - то есть отношения типов в первую очередь регулируются их идентификаторами.

## Show code snippet - `Assignability > Nominal`

В номинальных языках эти бы два типа не были равнозначны - у них разный идентификатор. Но у нас эти два типы равны, потому что у них одинаковая структура. А как быть с более сложными типами? Вот тут вернемся снова к идее о том, что типы это множества.

Что такое множество? Это просто какой-то набор элементов - с конечными множествами все понятно вполне: элементы можно просто перечислить. Но вот большинство множеств - они, скорее, определяеются набором требований, которым соотвествуют элементы этого множества. Например, множество всех четных чисел - мы же его определяем не как 2, 4, 6 и так далее, а как все числа, которые нацело делятся на 2.

Вот с типами так же - какие-то типы отображают конечное количество элементов, например `"a"|"b"`, но большинство типов имеют бесконечное количество элементов и определяются уже напрямую требованиями к значениям.

## Show code snippet - `Assignability > MinimalContract`

Рассмотрим функцию, которая на вход принимает `MutationObserver` - данный тип выставляет нам довольно небольшой набор требований: у нас должно быть 3 метода, в числе которых метод `takeRecords`, который должен возвращать массив. Можно также заметить, что метод `observe` должен принимать на вход какие-то аргументы.
Определим объект, на котором будут методы с необходимыми названиями, а также добавим метод `log`. Попробуем передать наш объект в функцию - никаких ошибок, хотя наш объект `MutationObsverver`-ом не является. Почему так?

Во-первых, все необходимые методы на нашем объекте имеются. Метод `takeRecords` возвращает массив, как и требовалось. Во-вторых, что насчет лишнего метода `log`? Ну, функцию его наличие никак не заботит - она о его существовании не знает, от его наличия хуже никому не стало. В-третьих, что с методом `observe` - разве он не должен уметь принимать на вход аргументы? Ну, если мы сравним методы `obverse` между нашим объектом и `MutationObserver`, то увидим, что наш метод является подтипом второго. Почему так? Что случится, если в наш метод передать какой-то параметр? Ну ведь ничего и не случится, так как наш метод аргументы никак не обрабатывает. Получается, по всем требованиям наш объект подходит.

Для всего это есть удобное понятие - минимальный контракт. Типы выставляют некий список требований - а типы значений проверяются на соответствие этим требованиям. Это и называется минимальным контрактом.

## Show code snippet - `Assignability > Juggler`

Представьте, что вы хотите нанять жонглера и в качестве требования к работе у вас - умение жонглировать. Если к вам придет кандидат, который этого не умеет - вы его отклоните. Если к вам придет кандидат, который умеет жонглировать, а также умеет играть на гитаре - ну, вам же лишь важно, только чтобы он умел жонглировать. При этом нанимать кандидата, про которого неясно то ли он умеет жонглировать, то ли играть на гитаре - вы бы не стали. Это как раз аналогично тому, как при объединении типов теряется информация.

## Show code snippet - `Assignability > Spy`

Представим другую ситуацию. Вам поручили поймать вражеского шпиона на какой-то вечеринке. У вас на руках три разных досье, в которых информация как можно опознать шпиона. В первом досье сказано, что у шпиона голубые глаза. Во втором, что у него голубые глаза и борода. А в третьем, что у него то ли голубые глаза, то ли борода. Какое из трех досье дает вам больше всего информации и с которым найти шпиона будет проще всего? Наименьше число людей попадает под описание из второго досье. А вот под третье наибольшее. Это как раз аналогично тому, как пересечения сужают типы, а объединения расширяют.

## Show code snippet - `Assignability > WhatIsToBeNarrower`

Рассмотрим на конкретных примерах. Вот глядя на эти два объекта - может по началу показаться, что первый тип является подтипом второго, потому что второй тип выглядит "больше". На самом деле, ровно наоборот - ведь второй тип выставляет дополнительные требования к значениям. При этом следует понимать, что чем больше требований выполняется, тем больше вещей "умеют" делать значения этого типа. Если один тип является подтипом другого - это значит, что он умеет все то же самое, что и другой тип, но также что-то еще дополнительно. Вот первый тип все что умеет - это свойство `a`, а вот у второго типа есть еще и свойство `b`.

При этом если мы рассмотрим два следующих объекта, то уже увидим, что они никак не связаны. Это означает, что ни один тип не является подтипом другого.

## Go to `3rd Venn diagram`

Это может быть лучше видно на такой диаграме - внешний круг это множество всех объектов со своством `a` типа `string | number`. А внутри него содержатся два подтипа, которые мы рассматривали - но ни один из них не содержит в себе целиком другой.

## Show code snippet - `Assignability > OptionalParameter`

Продолжая прошлый пример с функцией `observe` - первая функция принимает опциональный аргумент абсолютно любого типа, вторая функция не принимает никаких аргументов. Тем не менее сравнение этих типов сообщает нам, что они эквивалетны. Первую функцию можно вызывать без параметра, ведь он опционален. Вторую функцию тоже можно. Первую функцию можно вызвать с параметром любого типа. Но ведь как мы уже разобрались ранее, это верно и для второй функции. То есть свойства у этих функций и правда идентичны.

## Show code snippet - `Assignability > Never`

К слову о том, что чем больше свойств - тем ниже тип. А что насчет `never`? Раз это такое пустое множество, то и свойств у него, наверное, никаких нет? Но это вроде бы противоречит тому, что мы опредилили до этого? Чем ниже тип, тем больше свойств. Ну вот, на самом деле, свойств у `never` и правда очень много, а если точнее `never` умеет абсолютно все.
Если вспомнить, что `never` как правило получается при пересечении всяких несовместимых типов, то становится чуть яснее почему так. Если при пересечении типов, мы получаем тип, обладающий всеми их свойствами, то `never` обладает абсолютно всеми свойствами.
Поэтому можно столкнуться с такой неочевидной вещью, как `keyof never` - это `string | number | symbol`. Надеюсь, теперь стало понятнее почему так. И собственно, поэтому обращаться мы можем к любым его свойствам без каких-либо ошибок.

## Show code snippet - `Assignability > PropertyModifiers`

Модфикаторы свойств тоже могут влиять на иерархию типа.

Опциональные свойства находятся выше - поскольку мы ослабляем требование для значений. Тип слева требует наличие свойства, тип справа позволяет и значение, у которых есть это свойство, и те, у которых его нет.

Тем не менее Тайпскрипт не выделяет в этом плане неизменяемые свойства - формально возможность изменять объект это дополнительное требование и мы должны были бы наблюдать что первый тип является подтипом второго.

Также просто держите в уме, что Тайпскрипт делает немало допущений касаемо опциональных свойств. Как например, в данном случае - в обоих примерах типы не связаны друг с другом, но Тайпскрипт считает иначе.

Также когда в качестве ключа объекта указывается какой-то бесконечный тип, например `string`, то подразумевается, что все эти свойства опциональные - это называется `index signature`. Заметьте, что Тайпскрипт ожидаемо не требует, чтобы я в значениях указал все возможные ключи-строки, так как это, разумеется, невозможно.

# Generics

## Show code snippet - `Generics > Types`

Для того, чтобы подвести к следующей важной теме, я постараюсь вкратце объяснить, что такое дженерик типы. Это такие функции от мира типов - указываем аргументы, которые принимает дженерик, указываем его конструктор и после можем "вызывать" дженерик с конкретными типами. Дженерик тип это некая трансформация, которую мы применяем к другому типу. Например, дженерик `Pair` возвращает нам пару из переданного типа.

# Variance

## Show code snippet - `Variance`

И вот теперь мы подходим к теме, которая звучит страшнее, чем она есть на самом деле, а знать которую очень и очень полезно - речь пойдет про `variance`, "вариативность" по-русски. Не очень понятно, что это вообще значит, да?

Вариативность это свойство, которое говорит нам, в какую сторону по нашей иерархии будет двигаться тип при трансформациях. А простым языком - если мы возьмем тип `A` и его подтип `B`, то если мы прогоним оба этих типа через какой-то дженерик `G`, то `G<B>` будет подтипом `G<A>` или нет?

Первым вариантом является ковариативность - она означает, что чем более высокий тип будет передан в дженерик, тем более высокий тип мы получим на выходе. Вот у нас есть два типа `Narrow` и `Wide`, где первый является подтипом второго.

## Show code snippet - `Variance > Covariance`

Определим дженерик `WithA`, который будет просто создавать объект со свойством `a` и переданным типом. Теперь применим этот дженерик к каждому из наших типов и посмотрим как эти два типа соотносятся друг с другом - видно, что типы сохранили иерархию относительно друг друга. `WithA<Narrow>` является подтипом `WithA<Wide>`. Пока что думаю все понятно - это довольно прямолинейный тип вариативности.

### Show code snippet - `Variance > Contravariance > Keyof`

Рассмотрим теперь другой дженерик `Keyof`, который возвращает нам ключи переданного типа.
Давайте определим три типа - `Normal`, у которого есть одно свойство. После определим его подтип `Narrow`, у которого добавилось еще одно свойство. А после определим наоборот его надтип `Wide`, который гарантирует лишь наличие какого-то одно из двух свойств. И посмотрим, что `Keyof` нам будет возвращать для каждого из наших типов - для наиболее нижнего `Narrow` ожидаемо возвращает оба ключа, определенных на типе, для следующего `Normal` один ключ, а вот для самого верхнего типа `Wide` почему-то `never`.

Почему так? Ну, тут можно посмотреть с двух сторон. Когда мы запрашиваем ключи у типа - мы получаем список ключей, которые ГАРАНТИРОВАННО существуют на объекте. И в данном случае гарантировать мы не можем вообще ничего. Можно еще попробовать объяснить так - вспоминаем установку, что чем больше свойств, тем ниже тип, а чем их меньше, тем выше тип. Если наш тип `Wide` является надтипом `Normal`, то свойств у него должно быть меньше, то есть и ключей. Раз у `Normal` из ключей лишь один `"a"`, то ниже уже остается только `never`.

Посмотрим на отношения между нашими типами после `Keyof` трансформации - если `Narrow` был подтипом `Normal`, то `Keyof<Narrow>` является надтипом `Keyof<Normal>`. С остальными типами аналогично. То есть иерархия наоборот перевернулась - чем более высокий тип мы передаем в дженерик, тем более низкий тип мы получаем на выходе. Такой тип вариативности называется контравариативность.

Два самых ярких ее примера - это как раз ключи на объекте: чем ниже тип объекта, тем выше тип его ключей. Другой такой пример - это параметры на функции. Именно параметры, возвращаемый тип функции уже как раз ковариативен.

### Show code snippet - `Variance > Contravariance > Function`

Создадим дженерик `Func<T>`, который будет создавать функцию с параметром `T`. И теперь сравним типы `Func<Narrow>` и `Func<Wide>` - аналогично наблюдаем, что иерархия перевернулась. Может быть не очень интуитивно почему оно вообще так. Давайте посмотрим на это с такой стороны: чем больше разного рода параметров ваша функция принимает на ввод, тем "сложнее" ее написать. Функций, которые принимают на вход только строки больше, чем функций, которые принимают на вход и строки, и числа. Список требований к такой функции меньше.

Если посмотреть на конкретном примере, то вот две идентичные функции, но вторая умеет обрабатывать еще и числа. При этом если вторую функцию вызывать только со строками - ее поведение будет абсолютно идентично поведению первой функции.

### Show code snippet - `Variance > Contravariance > Squared`

Контравариативность в квадрате, кстати, дает ковариативность - если мы определим такой дженерик, возвращающий функцию, которая принимает на вход другую функцию, которая принимат на вход указанный тип, то контравариативности, так сказать, отменят друг друга. Первый уровень контравариативности в том, что у нас функция с параметром, а второй уровень контравариативности в том, что этот параметр - это функция, принимающая на вход параметр указанного типа. Получается наш дженерик `Func` ковариативен, что мы и наблюдаем.

### Show code snippet - `Variance > Contravariance > UnionAndIntersection`

Как следствие контравариативности в некоторых случаях можно еще наблюдать занятный эффект с объединениями и пересечениями.

Сделаем пару типов, на которых будем работать - тип `"a" | "c"` и `"b" | "c"`. У этих типов есть пересечение: это тип `"c"`. Сделаем также два объекта с данными ключами - `ACRecord` и `BCRecord`.

Возьмем теперь `Keyof<ACRecord>` и `Keyof<BCRecord>`, и возьмем их пересечение. Ключи `ACRecord` это `"a" | "c"`, ключи `BCRecord` это `"b" | "c"` - а их пересечение это `"c"`. Теперь возьмем объединение `ACRecrd` и `BCRecord` и возьмем ключи у этого объединения - получаем тоже `"c"`, потому что в случае объединения объектов мы получаем только ключи, которые гарантированно есть на объекте. Так вот, можем наблюдать, что пересечение ключей объектов это то же самое, что ключи объединения объектов.

Это свойство работает и в обратную сторону - ключи пересечения объектов равны объединению ключей объектов. Мы берем пересчение объектов `ACRecord` и `BCRecord` - значит, у итогового объекта должны быть свойства из обоих объектов, то есть `"a" | "b" | "c"`. Во втором же случае мы объединяем ключи `ACRecord`, то есть `"a" | "c"`, с ключами `BCRecord`, то есть `"b" | "c"` - получается опять же `"a" | "b" | "c"`.

Когда с этим можно столкнуться на практике? В чате какое-то время назад был вопрос по примерно такому случаю - есть массив из функций, где одна принимает на вход только строки, а другая только числа. И мы хотим пройтись по этому массиву и вызвать каждую функцию - но при попытке это сделать видна ошибка, что наша функция принимает на вход только `never`. У нас уже есть ответ на вопрос, почему так происходит - типом элемента массива является объединение этих двух функций. И аналогично предыдущим примерам объединение функций дает нам пересечение на ее параметрах, а пересечение `string` и `number` это `never`. Логика тут такая, что мы не знаем какую именно из двух функций мы вызываем - если мы будет передавать строку, то что должно случиться как мы дойдем до функции, принимающей число? И наоборот.

На втором примере видно, что если взять функции, у которых есть пересечение типов аргументов - так как обе функции способны принимать значение `"c"`, то в коллбэке уже нет ошибки, но вызвать функцию со значением `"a"` или `"b"` все так же нельзя.

## Show code snippet - `Variance > Invariance > Function`

Третий тип вариативности, на самом деле, самый частый - это инвариативность. Это означает, что наша трансформация приводит к тому, что между типами теряется иерархия. Самый простой пример этого функция, которая принимает на вход параметр некоего типа `T` и возвращает тот же самый тип. Определим такой дженерик `Identity<T>`. Если мы сравним таких две функции, сделанных из типа `Wide` и его подтипа `Narrow`, то увидим, что получившиеся функции никак друг с другом не связаны - ни одна не является подтипом другой. Так получается из-за того, что как мы помним параметры функций контравариативны, а вот возвращаемое значение, как я упоминал ранее - ковариативно. Получается одновременно и ковариативная, и контравариативная трансформация, то есть инвариативная. Это, в общем, самая частая причина инвариативности.

### Show code snippet - `Variance > Invariance > Object`

Вот другой пример инвариативности, где дженерик `SelfRecord` создает объект с указанными ключами и в качестве значений те же самые ключи. Опять же поскольку ключи контравариативны, а значения ковариативны - по итогу получается инвариативность.

## Show code snippet - `Variance > Bivariance > Constant`

Последний вид вариативности это в целом довольно редкий покемон, увидеть которого можно, в основном, в двух случаях - в довольно бессмысленном и тривиальном, и в другом, которого следует избегать. Этот вид назывывается бивариативность.

Рассмотрим дженерик `Null<T>`, который просто всегда возвращает `null` - то есть, результат которого никак не зависит от переданного параметра. Что будет если применить этот дженерик к нашим `Narrow` и `Wide` типам? Очевидно, что оба применения дадут `null`, и ожидаемо получаем, что результаты эквивалетны друг другу.

Бивариативность, это когда имея дженерик `F<T>` и при условии что `A` является подтипом `B`, то `F<A>` является подтипом `F<B>`, и одновременно с этим `F<B>` является подтипом `F<A>`. Если два типа являются подтипами друг друга одновременно, то как правило это означает что это один и тот же тип - аналогично тому если `a <= b` и `b <= a`, то очевидно, что `a = b`. В случае дженерика `Null<T>` это действительно так, ведь он всегда возвращает один и тот же тип. В непротиворечивой системе типизации такой вид дженериков это единственный случай, в котором бы наблюдалась бивариативность.

### Show code snippet - `Variance > Bivariance > Method`

Но в Тайпскрипте есть еще один случай, в котором намеренно допускается бивариативность - это объявления методов. Есть два способа объявить метод на каком-то объекте - это указать его как метод или указать его как свойство, равное функции. Объявление методом выглядит следующим образом - сделаем дженерик `Method<T>` который будет создавать объект с методом `a`. И вот что необычно - указав в дженерике наши типы `Narrow` и `Wide` итоговые типы `Method<Narrow>` и `Method<Wide>` оказываются эквивалентны друг другу. Хотя исходя из наших прошлых наблюдений про контравариативность на функциях - мы бы ожидали увидеть, что `Method<Wide>` это подтип `Method<Narrow>`.

В отличие от постоянных дженериков - не любые два типа произведут эквивалетные типы. Важно, чтобы один из исходных типов был подтипом другого. Если же типы не связаны по иерархии - то и итоговые типы тоже никак связаны не будут. Все то же самое относится и когда вы объявляете сами значения с методами.

### Show code snippet - `Variance > Bivariance > Property`

Если же мы рассмотрим аналогичные примеры, но где методы объявлены как свойства - то бивариативность теряется, и мы наблюдаем прежнюю контравариативность.

### Show code snippet - `Variance > Bivariance > Array`

К чему вообще такие допущения, если от них будто бы лишь хуже? Давайте сравним два массива, созданных из типов `Narrow` и `Wide` - что мы вообще ожидали бы наблюдать? Элементы массива аналогичны свойствам на объекте - то есть ковариативны. Но на массивах есть также методы вроде `push`, у которых в качестве аргумента тип элемента массива - то есть эти методы должны быть контравариативны. Получается, в конечном итоге любые два массива разных типов должны быть инвариативны. Тем не менее при попытке сравнить мы наблюдаем, что `Array<Narrow>` является подтипом `Array<Wide>` - это происходит потому, что методы на массивах объявлены именно с помощью методов, а не свойств. Ковариативные свойства и бивариативные методы в итоге нам дают ковариативные массивы.

Без этого создавать функции, работающие на массивах было бы очень проблематично - тут правда стоит отметить один нюанс. Массивы действительно должны быть инвариативны - в текущем виде можно наблюдать такую ошибку, где в наш численный массив добавляется `null`.

### Show code snippet - `Variance > Bivariance > ReadonlyArray`

Но к неизменяемым массивам это не относится - они взаправду ковариативны. Можно задаться вопросом насчет методов типа `concat` - ведь они есть и на неизменяемых массивах, и тоже принимают на вход только тип элемента массива. По идее мы должны тогда наблюдать ту же ситуацию с контравариативностью на методах.

Дело в том, что так как `concat` возвращает новый массив, то на вход он может принимать любые значения - следовательно, никакой контравариативности на подобных методах наблюдаться не будет. Тайпскрипт просто решил не переусложнять аннотацию этого метода, но на самом деле, ее можно было бы расширить, чтобы можно было передавать любые значения.

# Conclusion

Ну и чтобы подвести итоги. Эти две концепции - то, что типы это множества, и вариативность с ее подвидами, - это основы, которые я думаю, дают хорошую базу для понимания более продвинутых фичей в Тайпскрипте. Думать о типах как множествах, которые вы можете изобразить на диаграме Венна - я считаю очень удобной идеей, к которой можно обратиться, когда глядя на два типа вы не можете понять их иерархию интуитивно. А вариативность это очень важная концепция для понимания когда и почему какие типы совместимы друг с другом.

Это далеко не все, что предстоить узнать - я не затрагивал дистрибьютивность, `infer`, `satisfies`, `template literals` или `conditional types`. Но это уже все же конкретные фичи языка - я хотел рассказать про две главных абстрактных идеи, которые сильно помогут разобраться со всем остальным и которые распространяются на типизацию и во многих других языках тоже.

Всем спасибо за внимание.
