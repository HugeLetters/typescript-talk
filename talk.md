- Иерархия системы типов

  > Я подготовил доклад по системе типов в Тайпскрипте. Это не доклад про внутренную работу компилятора, оптимизации или малоизвестные фичи. Это доклад про общие концепции и абстракции, которые, я надеюсь, помогут Вам лучше понимать поведение типов. Я не буду рассказывать про то, как работает тайпскрипт - я постараюсь помочь понять, как работать с тайпскриптом.
  >
  > Для начала рассмотрим концепцию иерархии типов - я изобразил ее с помощью такого графа. Под иерархией подразумевается то, что типы стоящие выше по иерархии содержат в себе типы, которые находятся ниже них по иерархии. В верху иерархии находятся два типа - `any` и `unknown`.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Graph`**
  >
  > Они эквивалетны друг другу в том плане, что они оба содержат все остальные типы, потому они называются верхним типом, но также они содержат друг друга. В обычных условиях, это бы означало, что эти два типа равны, но это не совсем так. Об этом чуть далее.
  >
  > `unknown` содержит в себе 3 типа `{}`, `null`, и `void`. Тип `void` включает в себя тип `undefined`. Эти последние три типа обозначают все те значения в джаваскрипте, у которых нет свойств. В общем, все те типы, из-за которых вам приходится писать `?.`.
  > `{}` же наоборот все значения, у которых можно обращаться к свойствам и методам. Как бы парадоксально это ни смотрелось, сюда в том числе входят все примитивы - строки, числа и так далее. Не будем уходить в дебри коробочных значений для примитивов - это доклад про тайпскрипт.
  > Далее этот тип делится на `object`, куда уже как раз входят все не примитивные значения, и остальные типы для примитивов.
  >
  > В типы для примитивов также входят типы для их литералов - то есть конкретных значений. В `string` также входит `template literal` - это похоже на литералы для строк, но позволяет писать темплейт-строки аналогично джаваскрипту. Например, `` `this is a ${string}` ``.
  > В тип `object` входят все не примитивные значения - то есть POJO(то, что как правило мы подразумеваем под объектами), а также `Array`, `Date`, `Set`, `Map` и функции, что тоже важно держать в уме. И аналогично примитивам, у некоторых этих типов есть что-то вроде аналога литералов - для POJO можно указать, какие конкретно свойства и каких типов нам нужны. У массивов существует подтип `tuple` - это массив фиксированной длины, самый простой пример это `useState` в Реакте, он возвращает тупль `[state, setState]`. У функций в качестве подтипов существуют классы, и `function type expression`, с помощью которых можно изобразить конкретно форму функции, которая нас интересует: что принимает на ввод, что возвращает. То, что я перечислил аналоги литералов - это именно что аналоги. Литералы у примитивов как правило, если не всегда, соотносятся с каким-то одним конкретным значением - вот у объектов не так, поэтому я и сказал, что это аналогично литералам. У объектов подобные типы описывают все равно множество величин, причем вполне вероятно бесконечное - просто с ограничением на то, какие величины подходят под этот тип.
  >
  > А дальше по иерархии нам снова попадается `any` - вот в этом причудливость этого типа, что он одновременно по сути и верхний, и ПОЧТИ нижний тип, что формально не должно быть возможно. Но этот тип был введен именно как такой костыль/затычка для крайних случаев, где корректную типизацию внедрить не удавалось.
  > А вот еще ниже по ирерархии идет настоящий нижний тип - это `never`. То, что это нижний тип означает то, что таких значений существовать не должно - если у вас где-то в коде появилось значение с типом `never` - как правило, но не всегда, означает, что с точки зрения типизации это невозможный сценарий.
  > Это неплохая модель, чтобы для начала понять, что такое верхний тип, что такое нижний тип и что происходит между ними. Но на таком графе сложно понять, где на ним находятся объединения или пересечения типов - где на этом графе `({ a: string } & { b?: number }) | null`? Также на нем плохо видно, как соотносятся между собой всякие непримитивные типы - где относительно друг друга на иерархии находятся `{ a: string }` и `{a?: string | number }`?
  >
  > **GO TO VENN DIAGRAM**

- Типы как множества

  > Лучше понять как ответить на эти вопросы на поможет диграма Венна - с помощью нее можно изобразить различные множества и как они соотнятся друг с другом. Типы это тоже множества - то есть эдакая коллекция элементов: в данном контексте элементы это всевозможные значения, которые мог бы репрезентовать этот тип.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Venn`**
  >
  > Величина `"abcde"` представлена типом `string`, но также она может быть представлена типом `"abcde"` или типом `unknown`.
  > На диаграме видно, что у нас есть тип массив, который является подвидом неизменяемого массива, который является подвидом объекта, который является подвидом `unknown`. Это аналогично иерархии, что мы видели ранее на графе.

- Unions

  > Но также тут лучше видны отношения между типами - тип `string | object` находится рядом с множеством объектов, но также включает в себя дополнительное пространство - множество строк. `|` это Union, то есть объединение типов - такое логическое ИЛИ. При операции объединения итоговый тип получается такой же или выше по иерархии, чем был до этого - то есть количество потенциальных значений, которые попадают под этот тип увеличивается и он уже менее точно описывает поведение значения, которое он репрезентует. Если не совсем понятно, почему так - вспоминаем, что самый верхний тип это `unknown`, то есть про значение этого типа мы не знаем вообще ничего.

- Intersections

  > Если нас интересует пересечение типов `string | object` и `string | number`, то мы также видим его на диаграме - это будет просто множество всех строк. `&` это Intersection, то есть перечение типов - логическое И. Эта операция наоборот нам дает либо такой же тип, либо ниже по иерархии. Чем ниже тип - тем точнее он описывает значение, тем для нас лучше. В целом задача типизации подобрать наиболее низкий тип - если мы будет в качестве типа указывать тип выше, чем нам нужно, у нас будет меньше информации, с которой мы можем работать, но при этом мы не должны указывать тип ниже, чем нам нужно - чтобы не отсеивать значения, которые нам тоже могли бы подойти. Примерно по такому принципу и работает сам инференс в тайпскрипте - когда вы не указываете тип величины прямо, он старается подобрать наиболее низкий тип, который бы не противоречил указанной величине.
  >
  > **SHOW CODE SNIPPET - `Hierarchy > Intersection`**
  >
  > Касаемо того как это изображено на диаграме - это лишь иллюстрация, так что размеры, расположение кругов особого значения не имеют - нас по большому счету волнует только каким образом эти множества пересекаются: целиком, частично или вообще не пересекаются. Поэтому, например, множество `string | number` у нас представлено двумя раздельными областями - так в принципе возможно.
  > Из диаграмы также легко видно, где наш верхний тип `unknown` это область, внутри которой находятся абсолютно все другие множества. За пределами этой области ничего нет.
  >
  > **GO TO SECOND VENN DIAGRAM**
  >
  > Тут же находится наш нижний тип `never` - он находится на пересечении всех типов. Это по сути пустое множество, ни одна джаваскриптовая величина не может быть представлена этим типов. Нарисовать конечно все наши области так, чтоб они еще и все пересекались в одной точки - проблематично, но опять же напоминаю, что это все очень условное изображение.
  >
  > **GO TO THIRD VENN DIGRAM**
  >
  > Можно попробовать изобразить это вот так - где красная область это `never`. То, что это пустое множество не мешает нам нарисовать его не как точку, а как область. В любом случае, на практике об этом приходится думать в контексте 2-3 типов, для которых представить такую диаграму в голове - не проблема, зато понять соотношение типов с такой моделью довольно просто.
  > Может возникнуть резонный вопрос - а где же на этой диаграме `any`? Это как раз возвращаясь к тому, о чем я говорил ранее, что это то ли верхний, то ли нижний тип - так как тип построен на противоречии, он в эту модель особо не встраивается. Это больше к слову о том, о чем я говорил ранее, что это такой костыль - он не бесполезный, но лучше его приберечь для всяких ограничений на дженериках.

- Assignability
  - Множества определяются свойствами!
  - idea of minimal contract!
    <!-- todo - rewrite -->
    > На эти вопросы нам помогут ответить множества - те, что из математики. Что такое множество? Это просто какой-то набор элементов - с конечными множествами все понятно вполне: элементы можно просто перечислить. Но вот большинство множеств - они, скорее, определяеются набором свойств или требований, которые наблюдаются у элементов этого множества. Например, множество всех четных чисел - мы же его определяем не как 2, 4, 6 и так далее, а как все числа, которые нацело делятся на 2.
    > Вот с типами так же - какие-то типы отображают конечное количество элементов, где элементы по сути это наши реальные значения в рантайме, но больишнство типов имеют бесконечное количество элементов и определяются уже напрямую свойствами. То есть чтобы понять является ли что-то датой с точки зрения тайпскрипта - мы смотрим на то, какие вообще свойства есть у `Date`, смотрим выполняется ли это все для нашей величины, и если да, то для тайпскрипта наша величина это дата.
  - How object properties affect it's type
    - readonly properties
    - optional properties
  - `never` is an empty set but it can do everything!
- Advanced assignability - functions!!!!
  - covariance, contravariance, bivariance(not that important, but mention method declarations), invariance
- Footgun types:
  - object
  - {}
  - Function
- Branded types **Maybe this one isn't that important - I wanna focus on applicative/abstract parts**
  - Result type
  - type-level only branding
